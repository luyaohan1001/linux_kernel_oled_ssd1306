\hypertarget{driver_8c}{}\section{driver.\+c File Reference}
\label{driver_8c}\index{driver.\+c@{driver.\+c}}


This file implements the necessary i2c\+\_\+client probe and remove callbacks on the S\+S\+D1306 I2C bus device driver. On top of \hyperlink{driver_8c}{driver.\+c}, display configurations and initialization are implemented in \hyperlink{datalink_8c}{datalink.\+c}. On top of datalink, O\+L\+ED printing / graphics are implemented in \hyperlink{graphics_8c}{graphics.\+c}.  


{\ttfamily \#include \char`\"{}datalink.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}graphics.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}oled\+\_\+sysfs.\+h\char`\"{}}\newline
{\ttfamily \#include $<$linux/delay.\+h$>$}\newline
{\ttfamily \#include $<$linux/i2c.\+h$>$}\newline
{\ttfamily \#include $<$linux/kthread.\+h$>$}\newline
{\ttfamily \#include $<$linux/module.\+h$>$}\newline
{\ttfamily \#include $<$linux/sysfs.\+h$>$}\newline
Include dependency graph for driver.\+c\+:
% FIG 0
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{driver_8c_ad94b36675e7eb067ea3ce6ff9e244a44}\label{driver_8c_ad94b36675e7eb067ea3ce6ff9e244a44}} 
{\bfseries M\+O\+D\+U\+L\+E\+\_\+\+L\+I\+C\+E\+N\+SE} (\char`\"{}G\+PL\char`\"{})
\item 
\mbox{\Hypertarget{driver_8c_a594adc15634a4e56dcb80198b964a227}\label{driver_8c_a594adc15634a4e56dcb80198b964a227}} 
{\bfseries M\+O\+D\+U\+L\+E\+\_\+\+A\+U\+T\+H\+OR} (\char`\"{}Luyao Han\char`\"{})
\item 
\mbox{\Hypertarget{driver_8c_ae15b5df66e4e05b36899a90a8a9ff55d}\label{driver_8c_ae15b5df66e4e05b36899a90a8a9ff55d}} 
{\bfseries M\+O\+D\+U\+L\+E\+\_\+\+D\+E\+S\+C\+R\+I\+P\+T\+I\+ON} (\char`\"{}Linux kernel module driver for ssd1306 oled display\char`\"{})
\item 
static int \hyperlink{driver_8c_ac2ce7e7fa1f20b7193e04c34583885a2}{driver\+\_\+on\+\_\+probe} (struct \hyperlink{driver_8c_a77ca3c5047325f153b5679bce4576b39}{i2c\+\_\+client} $\ast$client, const struct i2c\+\_\+device\+\_\+id $\ast$device\+\_\+id)
\begin{DoxyCompactList}\small\item\em Callback function pointer called on probing (driver-\/device binding) of the device driver. This function implements the following prototype defined struct i2c\+\_\+driver in linux/i2c.\+h\+: int ($\ast$probe)(struct i2c\+\_\+client $\ast$client, const struct i2c\+\_\+device\+\_\+id $\ast$id);. \end{DoxyCompactList}\item 
static int \hyperlink{driver_8c_a1e690de4cdba34c6389cf7bdc76e13fa}{driver\+\_\+on\+\_\+remove} (struct \hyperlink{driver_8c_a77ca3c5047325f153b5679bce4576b39}{i2c\+\_\+client} $\ast$client)
\begin{DoxyCompactList}\small\item\em Callback function pointe called on the removal of the device driver. This function implements the following prototype defined struct i2c\+\_\+driver in linux/i2c.\+h\+: void ($\ast$remove)(struct i2c\+\_\+client $\ast$client);. \end{DoxyCompactList}\item 
static int \hyperlink{driver_8c_a3548630b2e8f1cda5127a5f940922edf}{oled\+\_\+display\+\_\+text\+\_\+thread} (void $\ast$parameters)
\begin{DoxyCompactList}\small\item\em Thread implementing for deploying oled\+\_\+graphics\+\_\+params.\+display\+\_\+text to oled screen. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{driver_8c_a0b2b1f66cb85cfa5ba687405cfea6be7}\label{driver_8c_a0b2b1f66cb85cfa5ba687405cfea6be7}} 
\hyperlink{driver_8c_a0b2b1f66cb85cfa5ba687405cfea6be7}{M\+O\+D\+U\+L\+E\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+T\+A\+B\+LE} (of, \hyperlink{driver_8c_ade8e0b3b58db81e759d44841b22828f4}{driver\+\_\+id})
\begin{DoxyCompactList}\small\item\em This macro describes which devices each specific driver can support. At compilation time, the build process extracts this information out of the driver and builds a table. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{driver_8c_a8039b804ca38fe27ebaba76416a5dd53}\label{driver_8c_a8039b804ca38fe27ebaba76416a5dd53}} 
{\bfseries M\+O\+D\+U\+L\+E\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+T\+A\+B\+LE} (i2c, \hyperlink{driver_8c_a43765295ecc04729376fab5e4e243172}{driver\+\_\+device\+\_\+id})
\item 
\mbox{\Hypertarget{driver_8c_a5a2507bec7b1d573cca5bf5f670b2254}\label{driver_8c_a5a2507bec7b1d573cca5bf5f670b2254}} 
{\bfseries module\+\_\+i2c\+\_\+driver} (i2c\+\_\+driver)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
struct i2c\+\_\+client $\ast$ \hyperlink{driver_8c_a77ca3c5047325f153b5679bce4576b39}{i2c\+\_\+client}
\begin{DoxyCompactList}\small\item\em Identifies the device (i.\+e. S\+S\+D1306 O\+L\+ED contoller) connected to the i2c bus. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{driver_8c_ada6aba8eaf924334f8cf13ee9edf8700}\label{driver_8c_ada6aba8eaf924334f8cf13ee9edf8700}} 
struct task\+\_\+struct $\ast$ \hyperlink{driver_8c_ada6aba8eaf924334f8cf13ee9edf8700}{handle\+\_\+display\+\_\+text\+\_\+thread}
\begin{DoxyCompactList}\small\item\em Points to the oled\+\_\+display\+\_\+text\+\_\+thread created. \end{DoxyCompactList}\item 
\hyperlink{structoled__graphics__params__t}{oled\+\_\+graphics\+\_\+params\+\_\+t} \hyperlink{driver_8c_ad7833cc3b12f3bc2e22d020ee60d2cd5}{oled\+\_\+graphics\+\_\+params}
\begin{DoxyCompactList}\small\item\em Link the symbol to its spawn in \hyperlink{graphics_8c}{graphics.\+c}. \end{DoxyCompactList}\item 
static struct of\+\_\+device\+\_\+id \hyperlink{driver_8c_ade8e0b3b58db81e759d44841b22828f4}{driver\+\_\+id} \mbox{[}$\,$\mbox{]}
\begin{DoxyCompactList}\small\item\em Specifies the \char`\"{}.\+compatible\char`\"{} strings. of\+\_\+device\+\_\+id array should store the same value as corresponding node\textquotesingle{}s \char`\"{}compatible\char`\"{} field in the device tree. In this case the oled.\+dts in the same directory has the \char`\"{}compatible\char`\"{} field. When the .compatible field here matches the device tree, the I2C device will be probed. \end{DoxyCompactList}\item 
static struct i2c\+\_\+device\+\_\+id \hyperlink{driver_8c_a43765295ecc04729376fab5e4e243172}{driver\+\_\+device\+\_\+id} \mbox{[}$\,$\mbox{]}
\begin{DoxyCompactList}\small\item\em This array is pointed by the id\+\_\+table field of struct i2c\+\_\+driver. The id\+\_\+table is used for non-\/\+DT based probing of I2\+C-\/devices. \end{DoxyCompactList}\item 
static struct i2c\+\_\+driver {\bfseries i2c\+\_\+driver}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This file implements the necessary i2c\+\_\+client probe and remove callbacks on the S\+S\+D1306 I2C bus device driver. On top of \hyperlink{driver_8c}{driver.\+c}, display configurations and initialization are implemented in \hyperlink{datalink_8c}{datalink.\+c}. On top of datalink, O\+L\+ED printing / graphics are implemented in \hyperlink{graphics_8c}{graphics.\+c}. 

\begin{DoxyAuthor}{Author}
Luyao Han (\href{mailto:luyaohan1001@gmail.com}{\tt luyaohan1001@gmail.\+com}) 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
12-\/21-\/2022 
\end{DoxyDate}


\subsection{Function Documentation}
\mbox{\Hypertarget{driver_8c_ac2ce7e7fa1f20b7193e04c34583885a2}\label{driver_8c_ac2ce7e7fa1f20b7193e04c34583885a2}} 
\index{driver.\+c@{driver.\+c}!driver\+\_\+on\+\_\+probe@{driver\+\_\+on\+\_\+probe}}
\index{driver\+\_\+on\+\_\+probe@{driver\+\_\+on\+\_\+probe}!driver.\+c@{driver.\+c}}
\subsubsection{\texorpdfstring{driver\+\_\+on\+\_\+probe()}{driver\_on\_probe()}}
{\footnotesize\ttfamily static int driver\+\_\+on\+\_\+probe (\begin{DoxyParamCaption}\item[{struct \hyperlink{driver_8c_a77ca3c5047325f153b5679bce4576b39}{i2c\+\_\+client} $\ast$}]{client,  }\item[{const struct i2c\+\_\+device\+\_\+id $\ast$}]{device\+\_\+id }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Callback function pointer called on probing (driver-\/device binding) of the device driver. This function implements the following prototype defined struct i2c\+\_\+driver in linux/i2c.\+h\+: int ($\ast$probe)(struct i2c\+\_\+client $\ast$client, const struct i2c\+\_\+device\+\_\+id $\ast$id);. 


\begin{DoxyParams}{Parameters}
{\em client} & Pointer to the i2c\+\_\+client instance. \\
\hline
{\em device\+\_\+id} & The device id to be probed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Error status. 
\end{DoxyReturn}
\mbox{\Hypertarget{driver_8c_a1e690de4cdba34c6389cf7bdc76e13fa}\label{driver_8c_a1e690de4cdba34c6389cf7bdc76e13fa}} 
\index{driver.\+c@{driver.\+c}!driver\+\_\+on\+\_\+remove@{driver\+\_\+on\+\_\+remove}}
\index{driver\+\_\+on\+\_\+remove@{driver\+\_\+on\+\_\+remove}!driver.\+c@{driver.\+c}}
\subsubsection{\texorpdfstring{driver\+\_\+on\+\_\+remove()}{driver\_on\_remove()}}
{\footnotesize\ttfamily static int driver\+\_\+on\+\_\+remove (\begin{DoxyParamCaption}\item[{struct \hyperlink{driver_8c_a77ca3c5047325f153b5679bce4576b39}{i2c\+\_\+client} $\ast$}]{client }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Callback function pointe called on the removal of the device driver. This function implements the following prototype defined struct i2c\+\_\+driver in linux/i2c.\+h\+: void ($\ast$remove)(struct i2c\+\_\+client $\ast$client);. 


\begin{DoxyParams}{Parameters}
{\em client} & Pointer to the i2c\+\_\+client instance. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
None. 
\end{DoxyReturn}
\mbox{\Hypertarget{driver_8c_a3548630b2e8f1cda5127a5f940922edf}\label{driver_8c_a3548630b2e8f1cda5127a5f940922edf}} 
\index{driver.\+c@{driver.\+c}!oled\+\_\+display\+\_\+text\+\_\+thread@{oled\+\_\+display\+\_\+text\+\_\+thread}}
\index{oled\+\_\+display\+\_\+text\+\_\+thread@{oled\+\_\+display\+\_\+text\+\_\+thread}!driver.\+c@{driver.\+c}}
\subsubsection{\texorpdfstring{oled\+\_\+display\+\_\+text\+\_\+thread()}{oled\_display\_text\_thread()}}
{\footnotesize\ttfamily static int oled\+\_\+display\+\_\+text\+\_\+thread (\begin{DoxyParamCaption}\item[{void $\ast$}]{parameters }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Thread implementing for deploying oled\+\_\+graphics\+\_\+params.\+display\+\_\+text to oled screen. 


\begin{DoxyParams}{Parameters}
{\em None.} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
None. 
\end{DoxyReturn}


\subsection{Variable Documentation}
\mbox{\Hypertarget{driver_8c_a43765295ecc04729376fab5e4e243172}\label{driver_8c_a43765295ecc04729376fab5e4e243172}} 
\index{driver.\+c@{driver.\+c}!driver\+\_\+device\+\_\+id@{driver\+\_\+device\+\_\+id}}
\index{driver\+\_\+device\+\_\+id@{driver\+\_\+device\+\_\+id}!driver.\+c@{driver.\+c}}
\subsubsection{\texorpdfstring{driver\+\_\+device\+\_\+id}{driver\_device\_id}}
{\footnotesize\ttfamily struct i2c\+\_\+device\+\_\+id driver\+\_\+device\+\_\+id\mbox{[}$\,$\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}
= \{\{\textcolor{stringliteral}{"oled\_device"}, 0\},
                                                  \{\}\}
\end{DoxyCode}


This array is pointed by the id\+\_\+table field of struct i2c\+\_\+driver. The id\+\_\+table is used for non-\/\+DT based probing of I2\+C-\/devices. 

\mbox{\Hypertarget{driver_8c_ade8e0b3b58db81e759d44841b22828f4}\label{driver_8c_ade8e0b3b58db81e759d44841b22828f4}} 
\index{driver.\+c@{driver.\+c}!driver\+\_\+id@{driver\+\_\+id}}
\index{driver\+\_\+id@{driver\+\_\+id}!driver.\+c@{driver.\+c}}
\subsubsection{\texorpdfstring{driver\+\_\+id}{driver\_id}}
{\footnotesize\ttfamily struct of\+\_\+device\+\_\+id driver\+\_\+id\mbox{[}$\,$\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}
= \{
    \{.compatible = \textcolor{stringliteral}{"ssd1306, oled\_device"}\}, \{\}\}
\end{DoxyCode}


Specifies the \char`\"{}.\+compatible\char`\"{} strings. of\+\_\+device\+\_\+id array should store the same value as corresponding node\textquotesingle{}s \char`\"{}compatible\char`\"{} field in the device tree. In this case the oled.\+dts in the same directory has the \char`\"{}compatible\char`\"{} field. When the .compatible field here matches the device tree, the I2C device will be probed. 

\mbox{\Hypertarget{driver_8c_a77ca3c5047325f153b5679bce4576b39}\label{driver_8c_a77ca3c5047325f153b5679bce4576b39}} 
\index{driver.\+c@{driver.\+c}!i2c\+\_\+client@{i2c\+\_\+client}}
\index{i2c\+\_\+client@{i2c\+\_\+client}!driver.\+c@{driver.\+c}}
\subsubsection{\texorpdfstring{i2c\+\_\+client}{i2c\_client}}
{\footnotesize\ttfamily struct i2c\+\_\+client$\ast$ i2c\+\_\+client}



Identifies the device (i.\+e. S\+S\+D1306 O\+L\+ED contoller) connected to the i2c bus. 

Pointer to the i2c\+\_\+client instance. \mbox{\Hypertarget{driver_8c_a407109b15209241099d7a1b7c3ae0ae0}\label{driver_8c_a407109b15209241099d7a1b7c3ae0ae0}} 
\index{driver.\+c@{driver.\+c}!i2c\+\_\+driver@{i2c\+\_\+driver}}
\index{i2c\+\_\+driver@{i2c\+\_\+driver}!driver.\+c@{driver.\+c}}
\subsubsection{\texorpdfstring{i2c\+\_\+driver}{i2c\_driver}}
{\footnotesize\ttfamily struct i2c\+\_\+driver i2c\+\_\+driver\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}
= \{
    
    .probe = \hyperlink{driver_8c_ac2ce7e7fa1f20b7193e04c34583885a2}{driver\_on\_probe},
    .remove = \hyperlink{driver_8c_a1e690de4cdba34c6389cf7bdc76e13fa}{driver\_on\_remove},
    .id\_table = \hyperlink{driver_8c_a43765295ecc04729376fab5e4e243172}{driver\_device\_id},
    .driver =
        \{
            .name = \textcolor{stringliteral}{"oled\_device"},
            .of\_match\_table = \hyperlink{driver_8c_ade8e0b3b58db81e759d44841b22828f4}{driver\_id},
        \},
\}
\end{DoxyCode}
\mbox{\Hypertarget{driver_8c_ad7833cc3b12f3bc2e22d020ee60d2cd5}\label{driver_8c_ad7833cc3b12f3bc2e22d020ee60d2cd5}} 
\index{driver.\+c@{driver.\+c}!oled\+\_\+graphics\+\_\+params@{oled\+\_\+graphics\+\_\+params}}
\index{oled\+\_\+graphics\+\_\+params@{oled\+\_\+graphics\+\_\+params}!driver.\+c@{driver.\+c}}
\subsubsection{\texorpdfstring{oled\+\_\+graphics\+\_\+params}{oled\_graphics\_params}}
{\footnotesize\ttfamily \hyperlink{structoled__graphics__params__t}{oled\+\_\+graphics\+\_\+params\+\_\+t} oled\+\_\+graphics\+\_\+params}



Link the symbol to its spawn in \hyperlink{graphics_8c}{graphics.\+c}. 

Link the symbol to its spawn in \hyperlink{graphics_8c}{graphics.\+c}.


\begin{DoxyParams}{Parameters}
{\em cursor\+\_\+coordinate} & Keeps track of the coordinate of current cursor. \\
\hline
{\em display\+\_\+text} & Buffers/keeps track of the current text on the oled\+\_\+screen. \\
\hline
\end{DoxyParams}
